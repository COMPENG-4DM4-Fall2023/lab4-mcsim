
#ifndef REQUESTSCHEDULER_FRFCFS_H
#define REQUESTSCHEDULER_FRFCFS_H

#include "../RequestScheduler.h"
using namespace std;
namespace Memulator{
	class RequestScheduler_FRFCFS: public RequestScheduler{
	private:
		vector<unsigned int> requestorIndex;

	public:
		RequestScheduler_FRFCFS(std::vector<RequestQueue*>&requestQueues, std::vector<CommandQueue*>& commandQueues, const std::map<unsigned int, bool>& requestorTable): 
			RequestScheduler(requestQueues, commandQueues, requestorTable) 
		{
			for(unsigned int index = 0; index < requestQueue.size(); index++) {
				requestorIndex.push_back(0);
			}
			index_temp = 0;
		}

		void requestSchedule()
		{
			cout<<"23"<<endl;
			for(size_t index =0; index < requestQueue.size(); index++) 
			{
				cout<<"26"<<endl;
				scheduledRequest = NULL;
				scheduledRequest_temp = NULL;
				if(requestQueue[index]->getSize(false,0) > 0) 						
				{
					cout<<"30"<<endl;
					scheduledRequest = scheduleFR(index); 	
					cout<<"33"<<endl;
					if(scheduledRequest != NULL)
					{		
						cout<<"35"<<endl;			
						scheduledRequest_temp = scheduledRequest;
						index_temp = index;
						break;
						//updateRowTable(scheduledRequest->addressMap[Rank], scheduledRequest->addressMap[Bank], scheduledRequest->row);
						//requestQueue[index]->removeRequest();
					}	
				}
				scheduledRequest = NULL;
			}
			cout<<"40"<<endl;
			for(size_t index =0; index < requestQueue.size(); index++) 
			{
				cout<<"41"<<endl;
				scheduledRequest = NULL;
				if(requestQueue[index]->getSize(false,0) > 0) 						
				{
					cout<<"42"<<endl;
					scheduledRequest = scheduleFR(index); 	
					cout<<"43"<<endl;
					if(scheduledRequest != NULL)
					{
						cout<<"44"<<endl;
						if(scheduledRequest->arriveTime < scheduledRequest_temp->arriveTime){
							cout<<"45"<<endl;
							scheduledRequest_temp = scheduledRequest;
							index_temp = index;
						}
					}	
				}
				scheduledRequest = NULL;
			}
			cout<<"46"<<endl;
			if(scheduledRequest_temp != NULL){
			cout<<"47"<<endl;
				if(isSchedulable(scheduledRequest, isRowHit(scheduledRequest)))
				{
					cout<<"48"<<endl;
					updateRowTable(scheduledRequest->addressMap[Rank], scheduledRequest->addressMap[Bank], scheduledRequest->row);
					requestQueue[index_temp]->removeRequest();
				}
			}
			else
			{
				cout<<"49"<<endl;
				for(size_t index =0; index < requestQueue.size(); index++) 
				{
					if(requestQueue[index]->getSize(false,0) > 0) 						
					{
						cout<<"47"<<endl;
						scheduledRequest = scheduleFR(index); 	
						if(isSchedulable(scheduledRequest, isRowHit(scheduledRequest)))
						{
							updateRowTable(scheduledRequest->addressMap[Rank], scheduledRequest->addressMap[Bank], scheduledRequest->row);
							requestQueue[index_temp]->removeRequest();
						}
					}	
				}
			}
		}
	};
}

#endif









/*********************************************************************************
*  Copyright (c) 2015-2016, Danlu Guo
*                             University of Waterloo
*                
*  All rights reserved.
*********************************************************************************/


#include <math.h>

#include "RequestScheduler.h"
#include "CommandGenerator.h"
#include "global.h"

using namespace std;
using namespace Memulator;

RequestScheduler::RequestScheduler(std::vector<RequestQueue*>&requestQueues, std::vector<CommandQueue*>& commandQueues, const std::map<unsigned int, bool>& requestorTable):
	requestorCriticalTable(requestorTable),
	requestQueue(requestQueues),
	commandQueue(commandQueues)
{
	commandGenerator = NULL;
	scheduledRequest = NULL;
	req1 = NULL;
	req2 = NULL;
	id = 0;
	clockCycle = 1;
}

RequestScheduler::~RequestScheduler()
{
	bankTable.clear();
}

void RequestScheduler::connectCommandGenerator(CommandGenerator *generator)
{
	commandGenerator = generator;
}

bool RequestScheduler::isRowHit(Request* request)
{
	
	bool isHit = false;
	// if(bankTable.find(request->rank) != bankTable.end()) {
	// 	if(bankTable[request->rank].find(request->bank) != bankTable[request->rank].end()) {
	// 		if(bankTable[request->rank][request->bank] == request->row){ isHit = true; }
	// 	}	
	// }
	if(bankTable.find(request->addressMap[Rank]) != bankTable.end()) {
		if(bankTable[request->rank].find(request->addressMap[Bank]) != bankTable[request->addressMap[Rank]].end()) {
			if(bankTable[request->addressMap[Rank]][request->addressMap[Bank]] == request->row){ 
				isHit = true; 
			}
		}	
	}
	
	return isHit;
}

Request* RequestScheduler::scheduleFR(unsigned int qIndex)
{
	if(requestQueue[qIndex]->getSize(false, 0) > 0) {		
		for(unsigned int index=0; index < requestQueue[qIndex]->getSize(false, 0); index++) {
			if(isRowHit(requestQueue[qIndex]->getRequestCheck(index))) {
				//cout<<"Is row hit"<<endl;
				return requestQueue[qIndex]->getRequest(index);
			}
		}
		return NULL;
	}
	else {
		//cout<<"there is no request"<<endl;
		return NULL;
	}
}
Request* RequestScheduler::scheduleF(unsigned int qIndex)
{
	if(requestQueue[qIndex]->getSize(false, 0) > 0) {
		return requestQueue[qIndex]->getRequest(0);
	}
	else {
		//cout<<"there is no request"<<endl;
		return NULL;
	}
}
Request* RequestScheduler::scheduleBLISS(unsigned int qIndex)
{
	flag = true;
	if(requestQueue[qIndex]->getSize(false, 0) > 0) {
		for(unsigned int index=0; index < requestQueue[qIndex]->getSize(false, 0); index++) {
			if(isRowHit(requestQueue[qIndex]->getRequestCheck(index))) {				
				req1 = requestQueue[qIndex]->getRequestCheck(index);
				if(blacklist[req1->requestorID] == false){
					req1 = requestQueue[qIndex]->getRequest(index);
					return req1;
				}
				else if(flag){
					id = index;
					flag = false;
				}
			}
		}
		flag = true;
		req1 = requestQueue[qIndex]->getRequest(id);
		return req1;
	}
	else {
		return NULL;
	}
}
Request* RequestScheduler::scheduleFR_Next(unsigned int qIndex)
{
	if(requestQueue[qIndex]->getSize(false, 0) > 0) {
		for(unsigned int index=1; index < requestQueue[qIndex]->getSize(false, 0); index++) {
			if(isRowHit(requestQueue[qIndex]->getRequest(index))) {
				return requestQueue[qIndex]->getRequest(index);
			}
		}
		return requestQueue[qIndex]->getRequest(1);
	}
	else {
		return NULL;
	}
}
bool RequestScheduler::isSchedulable(Request* request, bool open)
{
	return commandGenerator->commandGenerate(request, open);
}

void RequestScheduler::updateRowTable(unsigned rank, unsigned bank, unsigned row)
{
	bankTable[rank][bank] = row;
}

void RequestScheduler::step()
{
	clockCycle++;
}
